---
title: "Preprocessing the Grant (C075) retinal epithelial cells data set"
description: |
author:
  - name: Peter Hickey
    url: https://peterhickey.org
    affiliation: WEHI SCORE
    affiliation_url: https://www.wehi.edu.au/people/shalin-naik/3310/score
date: "`r Sys.Date()`"
output: distill::distill_article
editor_options:
  chunk_output_type: console
bibliography: ref.bib
---

```{r setup}
library(SingleCellExperiment)
library(here)
library(rmarkdown)
library(janitor)
library(BiocStyle)
library(ggplot2)
library(cowplot)

source(here("code", "helper_functions.R"))

# NOTE: Using >= 4 cores siezes up my laptop. Can use more on RStudio server.
options(
  "mc.cores" = ifelse(gsub("^rstudio-[0-9]+", "", Sys.info()[["nodename"]]) ==
                        ".hpc.wehi.edu.au", 8L, 2L))
register(MulticoreParam(workers = getOption("mc.cores")))

knitr::opts_chunk$set(fig.path = "C075_Grant_Coultas.preprocess_files/")
```

# Setting up the data

The count data were processed using `r Biocpkg("scPipe")` and available in a *SingleCellExperiment* object, along with their metadata (see [`data/SCEs/C075_Grant_Coultas.scPipe.SCE.rds`](../data/SCEs/C075_Grant_Coultas.scPipe.SCE.rds)).


```{r}
sce <- readRDS(here("data", "SCEs", "C075_Grant_Coultas.scPipe.SCE.rds"))
```

## Incorporating cell-based annotation

Cell-based annotations are included in the *colData* of the *SingleCellExperiment*.
For our analysis, we will only retain relevant metadata fields.

In particular, we keep the plate number (`plate_number`), well position (`well_position`), the sample type (`sample_type`), the genotype (`genotype`), and the mouse (`mouse`), the sex of the mouse (`sex`), and the sequencing run (`sequencing_run`).

We also include the FACS data used for gating and index sorting.

```{r}
mouse_sex <- read.csv(
  here("data", "sample_sheets", "mouse_sex.csv"),
  header = FALSE,
  comment.char = "",
  stringsAsFactors = FALSE)
colnames(mouse_sex) <- c("mouse", "sex")

# Construct new_colData
new_colData <- DataFrame(
  plate_number = factor(sce$plate_number),
  well_position = sce$well_position,
  sample_type = factor(sce$sample_name),
  genotype = factor(
    vapply(strsplit(sce$cell_type_descriptor, " "), "[[", character(1), 1),
    c("Control", "Mutant")),
  mouse = factor(
    gsub(
      " ",
      "",
      sub("(Control|Mutant) sample", "", sce$cell_type_descriptor))))
new_colData[["sex"]] <- dplyr::inner_join(
  dplyr::tibble(mouse = new_colData$mouse), mouse_sex) %>%
  dplyr::pull(sex) %>%
  factor()
# NOTE: The FACS data column names all start with 'B', 'V', 'Y', 'R', 'FSC' or
#       'SSC'.
facs_markers <- grep(
  "^B|^V|^R|^Y|^FSC|^SSC",
  colnames(colData(sce)),
  value = TRUE)
facs_data <- colData(sce)[, facs_markers]
# Assign new_colData to sce.
colData(sce) <- cbind(new_colData, facs_data)
```

```{r}
# Some useful colours
plate_number_colours <- setNames(
  RColorBrewer::brewer.pal(nlevels(sce$plate_number), "Set2"),
  levels(sce$plate_number))
sample_type_colours <- setNames(
  RColorBrewer::brewer.pal(nlevels(sce$sample_type), "Accent"),
  levels(sce$sample_type))
sample_type_colours <- sample_type_colours[!is.na(names(sample_type_colours))]
genotype_colours <- setNames(
  RColorBrewer::brewer.pal(4, "Set1")[3:4],
  levels(sce$genotype))
genotype_colours <- genotype_colours[!is.na(names(genotype_colours))]
mouse_colours <- setNames(
  Polychrome::dark.colors(nlevels(sce$mouse)),
  levels(sce$mouse))
sex_colours <- setNames(
  RColorBrewer::brewer.pal(4, "Set1")[1:2],
  levels(sce$sex))
```

### Summarising the data

This dataset contains samples from `r nlevels(sce$plate_number)` 384-well plates.
Figure \@ref(fig:breakdown-by-plate-number) shows that most plates have cells from a knockout and a wildtype mouse with each pair of mice on a plate are from the same sibship^[Mouse `#1824` acts as a control sample on two plates.].
The exception is the initial pilot plate, LC279, which has cells from a single control mouse.

```{r breakdown-by-plate-number, fig.asp = 1 / 3, layout = "l-body-outset", fig.cap = "Breakdown of of the samples by plate."}
plot_grid(
  ggplot(as.data.frame(colData(sce))) + 
    geom_bar(
      aes(x = plate_number, fill = sample_type),
      position = position_fill(reverse = TRUE)) +
    coord_flip() +
    ylab("Frequency") +
    scale_fill_manual(values = sample_type_colours) +
    theme_cowplot(font_size = 6),
  ggplot(as.data.frame(colData(sce))) + 
    geom_bar(
      aes(x = plate_number, fill = genotype),
      position = position_fill(reverse = TRUE)) +
    coord_flip() +
    ylab("Frequency") +
    scale_fill_manual(values = genotype_colours) +
    theme_cowplot(font_size = 6),
  ggplot(as.data.frame(colData(sce))) + 
    geom_bar(
      aes(x = plate_number, fill = mouse),
      position = position_fill(reverse = TRUE)) +
    coord_flip() +
    ylab("Frequency") +
    scale_fill_manual(values = mouse_colours) +
    theme_cowplot(font_size = 6),
  ggplot(as.data.frame(colData(sce))) + 
    geom_bar(
      aes(x = plate_number, fill = sex),
      position = position_fill(reverse = TRUE)) +
    coord_flip() +
    ylab("Frequency") +
    scale_fill_manual(values = sex_colours) +
    theme_cowplot(font_size = 6),
  ggplot(as.data.frame(colData(sce))) + 
    geom_bar(aes(x = plate_number, fill = plate_number)) +
    coord_flip() +
    ylab("Number of wells") +
    scale_fill_manual(values = plate_number_colours) +
    theme_cowplot(font_size = 6),
  align = "v",
  ncol = 3)
```

The complete metadata table (excluding FACS data) is shown below.

```{r}
j <- Reduce(
  union,
  lapply(
    facs_markers,
    function(x) grep(x, colnames(colData(sce)))))
paged_table(.adf(colData(sce)[, -j]))
```

## Incorporating gene-based annotation

Having quantified gene expression against the GENCODE gene annotation, we have Ensembl-style identifiers for the genes. 
These identifiers are used as they are unambiguous and highly stable. 
However, they are difficult to interpret compared to the gene symbols which are more commonly used in the literature.
Given the Ensembl identifiers, we obtain the corresponding gene symbols using annotation packages available through Bioconductor.
Henceforth, we will use gene symbols (where available) to refer to genes in our analysis and otherwise use the Ensembl-style gene identifiers^[Some care is taken to account for missing and duplicate gene symbols; missing symbols are replaced with the Ensembl identifier and duplicated symbols are concatenated with the (unique) Ensembl identifiers.].

```{r}
library(EnsDb.Mmusculus.v79)
ensembl <- gsub("\\.[0-9]+$", "", rownames(sce))
symb <- mapIds(
  x = EnsDb.Mmusculus.v79, 
  # NOTE: Need to remove gene version number prior to lookup.
  keys = ensembl,
  keytype = "GENEID",
  column = "SYMBOL")
rowData(sce)$ENSEMBL <- ensembl
rowData(sce)$SYMBOL <- symb
# Replace the row names of the SCE by the gene symbols (where available).
library(scater)
rownames(sce) <- uniquifyFeatureNames(rownames(sce), rowData(sce)$SYMBOL)
# Add chromosome location so we can filter on mitochondrial genes.
location <- mapIds(
  x = EnsDb.Mmusculus.v79, 
  # NOTE: Need to remove gene version number prior to lookup.
  keys = rowData(sce)$ENSEMBL,
  keytype = "GENEID",
  column = "SEQNAME")
rowData(sce)$CHR <- location
```

# Quality control of cells

## Defining the quality control metrics

Low-quality cells need to be removed to ensure that technical effects do not distort downstream analysis results.
We use several quality control (QC) metrics to measure the quality of the cells:

- `sum`: This measures the library size of the cells, which is the total sum of counts across both genes and spike-in transcripts. We want cells to have high library sizes as this means more RNA has been successfully captured during library preparation. 
- `detected`: This is the number of expressed features^[The number of expressed genes refers to the number of genes which have non-zero counts (ie. they have been identified in the cell at least once)] in each cell. Cells with few expressed features are likely to be of poor quality, as the diverse transcript population has not been successfull captured. 
- `altexps_ERCC_detected`: This measures the proportion of reads which are mapped to spike-in transcipts relative to the library size of each cell. High proportions are indicative of poor-quality cells, where endogenous RNA has been lost during processing (e.g., due to cell lysis or RNA degradation). 
The same amount of spike-in RNA to each cell, so an enrichment in spike-in counts is symptomatic of loss of endogenous RNA.
- `subsets_Mt_percent`: This measures the proportion of reads which are mapped to mitochondrial RNA. If there is a higher than expected proportion of mitochondrial RNA this is often symptomatic of a cell which is under stress and is therefore of low quality and will not be used for the analysis. 

For CEL-Seq2 data, we typically observe library sizes that are in the tens of thousands^[This is consistent with the use of UMI counts rather than read counts, as each transcript molecule can only produce one UMI count but can yield many reads after fragmentation.] and several thousand expressed genes per cell.

```{r, results = "hide"}
is_mito <- rowData(sce)$CHR == "MT"
summary(is_mito)
sce <- addPerCellQC(sce, subsets = list(Mt = which(is_mito)))
```

The aim is to remove putative low-quality cells that have low library sizes, low numbers of expressed features, and high spike-in (or mitochondrial) proportions. 
Such cells can interfere with downstream analyses, e.g., by forming distinct clusters that complicate interpretation of the results.

## Visualizing the QC metrics

The distributions of these metrics are shown in Figure \@ref(fig:qcplot-by-plate-by-mouse), stratified by plate and mouse.

```{r qcplot-by-plate-by-mouse, fig.cap = "Distributions of various QC metrics for all cells in the data set. This includes the library sizes, number of expressed genes, and proportion of reads mapped to spike-in transcripts or mitochondrial genes.", layout = "l-page", fig.asp = 2 / 3}
sce$plate_number.mouse <- factor(paste0(sce$plate_number, ".", sce$mouse))
plot_grid(
  ggplot(
    data = as.data.frame(colData(sce)),
    aes(
      x = plate_number.mouse,
      y = sum,
      colour = genotype,
      fill = genotype)) +
    geom_violin(scale = "width", width = 0.8, alpha = 0.2) +
    ggbeeswarm::geom_quasirandom(size = 0.1) +
    theme_cowplot(font_size = 4) +
    scale_colour_manual(values = genotype_colours) + 
    scale_fill_manual(values = genotype_colours) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    scale_y_log10(limits = c(1, NA)) +
    annotation_logticks(
      sides = "l",
      short = unit(0.03, "cm"),
      mid = unit(0.06, "cm"),
      long = unit(0.09, "cm")),
  ggplot(
    data = as.data.frame(colData(sce)),
    aes(
      x = plate_number.mouse,
      y = altexps_ERCC_percent,
      colour = genotype,
      fill = genotype)) +
    geom_violin(scale = "width", width = 0.8, alpha = 0.2) +
    ggbeeswarm::geom_quasirandom(size = 0.1) +
    ylim(0, 100) +
    theme_cowplot(font_size = 4) +
    scale_colour_manual(values = genotype_colours) + 
    scale_fill_manual(values = genotype_colours) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)),
  ggplot(
    data = as.data.frame(colData(sce)),
    aes(
      x = plate_number.mouse,
      y = detected,
      colour = genotype,
      fill = genotype)) +
    geom_violin(scale = "width", width = 0.8, alpha = 0.2) +
    ggbeeswarm::geom_quasirandom(size = 0.1) +
    theme_cowplot(font_size = 4) +
    scale_colour_manual(values = genotype_colours) + 
    scale_fill_manual(values = genotype_colours) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    scale_y_log10(limits = c(1, NA)) +
    annotation_logticks(
      sides = "l",
      short = unit(0.03, "cm"),
      mid = unit(0.06, "cm"),
      long = unit(0.09, "cm")),
  ggplot(
    data = as.data.frame(colData(sce)),
    aes(
      x = plate_number.mouse,
      y = subsets_Mt_percent,
      colour = genotype,
      fill = genotype)) +
    geom_violin(scale = "width", width = 0.8, alpha = 0.2) +
    ggbeeswarm::geom_quasirandom(size = 0.1) +
    ylim(0, 100) +
    theme_cowplot(font_size = 4) +
    scale_colour_manual(values = genotype_colours) + 
    scale_fill_manual(values = genotype_colours) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)),
  ncol = 2,
  align = "v")
```

Figure \@ref(fig:qcplot-by-plate-by-mouse-faceted) breaks the data down by whether a sample is a '20 cells' or a 'single cell'.

```{r qcplot-by-plate-by-mouse-faceted, fig.cap = "Distributions of various QC metrics for all cells in the data set. This includes the library sizes, number of expressed genes, and proportion of reads mapped to spike-in transcripts or mitochondrial genes.", layout = "l-page", fig.asp = 2 / 3}
plot_grid(
  ggplot(
    data = as.data.frame(colData(sce)),
    aes(
      x = plate_number.mouse,
      y = sum,
      colour = genotype,
      fill = genotype)) +
    geom_violin(scale = "width", width = 0.8, alpha = 0.2) +
    ggbeeswarm::geom_quasirandom(size = 0.1) +
    theme_cowplot(font_size = 4) +
    scale_colour_manual(values = genotype_colours) + 
    scale_fill_manual(values = genotype_colours) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    scale_y_log10(limits = c(1, NA)) +
    annotation_logticks(
      sides = "l",
      short = unit(0.03, "cm"),
      mid = unit(0.06, "cm"),
      long = unit(0.09, "cm")) + 
    facet_grid(~ sample_type),
  ggplot(
    data = as.data.frame(colData(sce)),
    aes(
      x = plate_number.mouse,
      y = altexps_ERCC_percent,
      colour = genotype,
      fill = genotype)) +
    geom_violin(scale = "width", width = 0.8, alpha = 0.2) +
    ggbeeswarm::geom_quasirandom(size = 0.1) +
    ylim(0, 100) +
    theme_cowplot(font_size = 4) +
    scale_colour_manual(values = genotype_colours) + 
    scale_fill_manual(values = genotype_colours) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) + 
    facet_grid(~ sample_type),
  ggplot(
    data = as.data.frame(colData(sce)),
    aes(
      x = plate_number.mouse,
      y = detected,
      colour = genotype,
      fill = genotype)) +
    geom_violin(scale = "width", width = 0.8, alpha = 0.2) +
    ggbeeswarm::geom_quasirandom(size = 0.1) +
    theme_cowplot(font_size = 4) +
    scale_colour_manual(values = genotype_colours) + 
    scale_fill_manual(values = genotype_colours) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    scale_y_log10(limits = c(1, NA)) +
    annotation_logticks(
      sides = "l",
      short = unit(0.03, "cm"),
      mid = unit(0.06, "cm"),
      long = unit(0.09, "cm")) + 
    facet_grid(~ sample_type),
  ggplot(
    data = as.data.frame(colData(sce)),
    aes(
      x = plate_number.mouse,
      y = subsets_Mt_percent,
      colour = genotype,
      fill = genotype)) +
    geom_violin(scale = "width", width = 0.8, alpha = 0.2) +
    ggbeeswarm::geom_quasirandom(size = 0.1) +
    ylim(0, 100) +
    theme_cowplot(font_size = 4) +
    scale_colour_manual(values = genotype_colours) + 
    scale_fill_manual(values = genotype_colours) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) + 
    facet_grid(~ sample_type),
  ncol = 2,
  align = "v")
```

It is also valuable to examine how the QC metrics behave with respect to each other (Figure \@ref(fig:qcbiplot)). 
Generally, they will be in rough agreement, i.e., cells with low total counts will also have low numbers of expressed features and high ERCC/mitochondrial proportions.
Clear discrepancies may correspond to technical differences between batches of cells or genuine biological differences in RNA content.

```{r qcbiplot, fig.cap = "Behaviour of each QC metric compared to the total number of expressed features. Each point represents a cell in the data set.", fig.width = 10, fig.asp = 0.5}
par(mfrow = c(1, 3))
plot(
  x = sce$detected, 
  y = sce$sum / 1e3,
  xlab = "Number of expressed genes",
  ylab = "Library size (thousands)")
plot(
  x = sce$detected,
  y = sce$altexps_ERCC_percent, 
  xlab = "Number of expressed genes",
  ylab = "ERCC proportion (%)",
  ylim = c(0, 100))
plot(
  x = sce$detected, 
  y = sce$subsets_Mt_percent,
  xlab = "Number of expressed genes",
  ylab = "Mitochondrial proportion (%)",
  ylim = c(0, 100))
```

Overall, most single-cell samples have performed similarly in terms of library size, number of genes detected, and percentage of reads coming from the ERCC spike-ins and mitochondria transcripts.
As expected, the 20 cell samples typically have larger library sizes, more genes detected, and a lower percentage of reads coming from ERCC spike-ins and mitochondrial transcripts.
For now, however, we focus on the single cell data and remove the 20-cell samples.

```{r}
sce <- sce[, sce$sample_type == "single cell"]
# NOTE: Update the factor columns.
colData(sce) <- DataFrame(
  lapply(colData(sce), function(x) {
    if (is.factor(x)) {
      factor(x)
    } else {
      x
    }
  }),
  row.names = colnames(sce))
```


There are some plates with a higher average percentage of reads coming from the ERCC spike-ins (LC294 and LC358) or with a subset of samples with notably larger values (LC398).
Similarly, there are some plates with a higher average percentage of reads coming from the mitochondrial transcripts (LC358 and LC294).
We will investigate these futher in [Investigating plates with large ERCC percentages].

### Investigating plates with large ERCC and mitochondrial percentages

Figure \@ref(fig:plate-map-ercc) shows the percentage of reads coming from the ERCC spike-ins by plate position, which can sometimes help identify whether a plate has come out of alignment during the sort.

```{r plate-map-ercc, fig.cap = "Percentage of reads coming from ERCC spike-ins for all single-cell samples in the dataset plotted by plate position. The colour scale runs from dark blue (0% of reads coming from ERCC spike-ins) to bright yellow (45% of reads coming from ERCC spike-ins) with mutant cells drawn as triangles and control cells as circles."}
p <- lapply(levels(sce$plate_number), function(p) {
  z <- sce[, sce$plate_number == p]
  plotPlatePosition(
    z,
    as.character(z$well_position),
    colour_by = "altexps_ERCC_percent",
    point_size = 4,
    point_alpha = 1,
    theme_size = 8,
    by_show_single = TRUE,
    shape = "genotype") +
    ggtitle(p) +
    scale_colour_viridis_c(
      limits = c(0, 45),
      breaks = seq(0, 45, 10)) +
    scale_shape_manual(values = c("Control" = 16, "Mutant" = 17)) + 
    theme(legend.position = "none")
})
fig_path <- "C075_Grant_Coultas.preprocess_files/plate-map-ercc.png"
ggsave(
  fig_path,
  multiplot(plotlist = p, cols = 2),
  width = 300,
  height = 450,
  units = "mm")
knitr::include_graphics(fig_path)
```

For plate LC398, we see that there is a systematic trend of mutant cells on the right hand side of the plate having higher percentage of reads coming from the ERCC spike-ins.
This may be due to the plate coming out of alignment and means that caution is warranted when interpreting mutant cells from this plate.

Figure \@ref(fig:plate-map-mt) shows the percentage of reads coming from mitochondrial transcripts by plate position.

```{r plate-map-mt, fig.cap = "Percentage of reads coming from mitochondrial transcripts for all single-cell samples in the dataset plotted by plate position. The colour scale runs from dark blue (0% of reads coming from mitochondrial transcripts) to bright yellow (45% of reads coming from mitochondrial transcripts) with mutant cells drawn as triangles and control cells as circles."}
p <- lapply(levels(sce$plate_number), function(p) {
  z <- sce[, sce$plate_number == p]
  plotPlatePosition(
    z,
    as.character(z$well_position),
    colour_by = "subsets_Mt_percent",
    point_size = 4,
    point_alpha = 1,
    theme_size = 8,
    by_show_single = TRUE) +
    ggtitle(p) +
    scale_colour_viridis_c(
      limits = c(0, 45),
      breaks = seq(0, 45, 10)) +
    scale_shape_manual(values = c("Control" = 16, "Mutant" = 17)) + 
    theme(legend.position = "none")
})
fig_path <- "C075_Grant_Coultas.preprocess_files/plate-map-mt.png"
ggsave(
  fig_path,
  multiplot(plotlist = p, cols = 2),
  width = 300,
  height = 450,
  units = "mm")
knitr::include_graphics(fig_path)
```

There is no systematic trend by plate position for the percentage of reads coming from mitochondrial transcripts.

## Identifying outliers by each metric

Outliers are defined based on the median absolute deviation (MADs) from the median value of each metric across all cells. 
We remove small and large outliers for the library size and the number of expressed features, and large outliers for the spike-in proportions. 
Removal of low-quality cells is then performed by combining the filters for all of the metrics.

Due to the differences in the QC metrics by plate, we will compute our outlier thresholds at the plate-level.
However, if an entire plate failed, outlier detection will not be able to act as an appropriate QC filter for that plate.
In this case, it is generally better to compute a shared median and MAD from the other plates and use those estimates to obtain an appropriate filter threshold for cells in the problematic plates.

```{r, results = "hide"}
# NOTE: This is useful rule of thumb way to identifying problematic batches
#       https://osca.bioconductor.org/quality-control.html#quality-control-outlier
libsize_drop <- isOutlier(
  metric = sce$sum, 
  nmads = 3,
  type = "lower", 
  log = TRUE,
  batch = sce$plate_number)
libsize_drop_thresholds <- attributes(libsize_drop)$thresholds["lower", ]
libsize_drop_subset <- names(
  libsize_drop_thresholds)[isOutlier(
    libsize_drop_thresholds,
    type = "lower",
    log = TRUE)]
feature_drop <- isOutlier(
  metric = sce$detected, 
  nmads = 3,
  type = "lower", 
  log = TRUE,
  batch = sce$plate_number)
feature_drop_thresholds <- attributes(feature_drop)$thresholds["lower", ]
feature_drop_subset <- names(
  feature_drop_thresholds)[isOutlier(
    feature_drop_thresholds,
    type = "lower",
    log = TRUE)]
spike_drop <- isOutlier(
  metric = sce$altexps_ERCC_percent, 
  nmads = 3, 
  type = "higher",
  batch = sce$plate_number)
spike_drop_thresholds <- attributes(spike_drop)$thresholds["higher", ]
spike_drop_subset <- names(
  spike_drop_thresholds)[isOutlier(spike_drop_thresholds, type = "higher")]
mito_drop <- isOutlier(
  metric = sce$subsets_Mt_percent, 
  nmads = 3, 
  type = "higher",
  batch = sce$plate_number)
mito_drop_thresholds <- attributes(mito_drop)$thresholds["higher", ]
mito_drop_subset <- names(
  mito_drop_thresholds)[isOutlier(mito_drop_thresholds, type = "higher")]

libsize_drop <- isOutlier(
  metric = sce$sum, 
  nmads = 3,
  type = "lower", 
  log = TRUE,
  batch = sce$plate_number,
  subset = !sce$plate_number %in% libsize_drop_subset)
feature_drop <- isOutlier(
  metric = sce$detected,
  nmads = 3, 
  type = "lower", 
  log = TRUE,
  batch = sce$plate_number,
  subset = !sce$plate_number %in% feature_drop_subset)
spike_drop <- isOutlier(
  metric = sce$altexps_ERCC_percent, 
  nmads = 3, 
  type = "higher",
  batch = sce$plate_number,
  # NOTE: Force LC398 to be included in subset.
  subset = !sce$plate_number %in% union(spike_drop_subset, "LC398"))
mito_drop <- isOutlier(
  metric = sce$subsets_Mt_percent, 
  nmads = 3, 
  type = "higher",
  batch = sce$plate_number,
  # NOTE: LC294 and LC358 are outliers for mito%, although Zoe says she doesn't
  #       know of any good reason for this result. We don't `subset` these
  #       plates because otherwise almost all cells on these plates are 
  #       excluded. Instead, we will just keep an eye on these cells in 
  #       downstream analysis and possible exclude mitochondrial transcripts 
  #       from some analyses.
  # subset = !sce$plate_number %in% mito_drop_subset
)
```

The following table summarises the QC cutoffs:

```{r}
libsize_drop_df <- data.frame(
  plate_number = colnames(attributes(libsize_drop)$thresholds),
  lower = attributes(libsize_drop)$thresholds["lower", ])
feature_drop_df <- data.frame(
  plate_number = colnames(attributes(feature_drop)$thresholds),
  lower = attributes(feature_drop)$thresholds["lower", ])
spike_drop_df <- data.frame(
  plate_number = colnames(attributes(spike_drop)$thresholds),
  lower = attributes(spike_drop)$thresholds["higher", ])
mito_drop_df <- data.frame(
  plate_number = colnames(attributes(mito_drop)$thresholds),
  lower = attributes(mito_drop)$thresholds["higher", ])

qc_cutoffs_df <- Reduce(
  function(x, y) dplyr::inner_join(x, y, by = "plate_number"),
  list(libsize_drop_df, feature_drop_df, spike_drop_df, mito_drop_df))
colnames(qc_cutoffs_df) <- c(
  "plate_number", "total counts", "total features", "%ERCC", "%mito")
qc_cutoffs_df %>%
  knitr::kable(caption = "QC cutoffs", digits = 1)
```

```{r}
sce_pre_QC_outlier_removal <- sce
keep <- !(libsize_drop | feature_drop | spike_drop | mito_drop)
sce <- sce[, keep]
```

The table below summarises the number of cells per plate left following removal of outliers based on the QC metrics.
The vast majority of cells are retained for most plates, with the exception of plate LC398.
More cells are removed based high percentages of ERCC transcripts or mitochondrial RNA than on low library size and number of expressed genes.
In total, we remove `r sum(!keep)` cells based on these QC metrics, and retain `r sum(keep)` cells.

```{r}
data.frame(
  ByLibSize = tapply(
    libsize_drop, 
    sce_pre_QC_outlier_removal$plate_number, 
    sum),
  ByFeature = tapply(
    feature_drop, 
    sce_pre_QC_outlier_removal$plate_number, 
    sum), 
  BySpike = tapply(
    spike_drop, 
    sce_pre_QC_outlier_removal$plate_number, 
    sum,
    na.rm = TRUE),
  ByMito = tapply(
    mito_drop, 
    sce_pre_QC_outlier_removal$plate_number, 
    sum,
    na.rm = TRUE),
  Remaining = as.vector(unname(table(sce$plate_number))),
  PercRemaining = round(
    100 * as.vector(unname(table(sce$plate_number))) /
      as.vector(
        unname(
          table(sce_pre_QC_outlier_removal$plate_number))), 1)) %>%
  tibble::rownames_to_column("plate_number") %>%
  dplyr::arrange(desc(PercRemaining)) %>%
  knitr::kable(
    caption = "Number of samples removed by each QC step and the number of samples remaining, ordered by the percentage of cells remaining.")
```

### Summary

Finally, we look at the QC metrics for the cells remaining after outlier removal.
Figure \@ref(fig:qcplot-post-outlier-removal-by-plate-by-mouse) shows most plates have similar QC metrics, as is to be expected following quality control.

```{r qcplot-post-outlier-removal-by-plate-mouse, fig.cap = "Distribution of QC metrics for each plate in the dataset. Each point represents a cell and is colored according to whether it was discarded during the QC process. Note that a cell will only be kept if it passes the relevant threshold for all four QC metrics.", layout = "l-page", fig.asp = 0.7}
sce_pre_QC_outlier_removal$keep <- keep

plot_grid(
  ggplot(
    data = as.data.frame(colData(sce_pre_QC_outlier_removal)),
    aes(x = plate_number.mouse, y = sum)) +
    geom_violin(scale = "width", width = 0.8, alpha = 0.2) +
    ggbeeswarm::geom_quasirandom(size = 0.2, aes(colour = keep)) +
    theme_cowplot(font_size = 4) +
    theme(axis.text.x = element_text(angle = 60, hjust = 1)) +
    scale_y_log10(limits = c(1, NA)) +
    annotation_logticks(
      sides = "l",
      short = unit(0.03, "cm"),
      mid = unit(0.06, "cm"),
      long = unit(0.09, "cm")),
  ggplot(
    data = as.data.frame(colData(sce_pre_QC_outlier_removal)),
    aes(x = plate_number.mouse, y = altexps_ERCC_percent)) +
    geom_violin(scale = "width", width = 0.8, alpha = 0.2) +
    ggbeeswarm::geom_quasirandom(size = 0.2, aes(colour = keep)) +
    ylim(0, 100) +
    theme_cowplot(font_size = 4) +
    theme(axis.text.x = element_text(angle = 60, hjust = 1)),
  ggplot(
    data = as.data.frame(colData(sce_pre_QC_outlier_removal)),
    aes(x = plate_number.mouse, y = detected)) +
    geom_violin(scale = "width", width = 0.8, alpha = 0.2) +
    ggbeeswarm::geom_quasirandom(size = 0.2, aes(colour = keep)) +
    theme_cowplot(font_size = 4) +
    theme(axis.text.x = element_text(angle = 60, hjust = 1)) +
    scale_y_log10(limits = c(1, NA)) +
    annotation_logticks(
      sides = "l",
      short = unit(0.03, "cm"),
      mid = unit(0.06, "cm"),
      long = unit(0.09, "cm")),
  ggplot(
    data = as.data.frame(colData(sce_pre_QC_outlier_removal)),
    aes(x = plate_number.mouse, y = subsets_Mt_percent)) +
    geom_violin(scale = "width", width = 0.8, alpha = 0.2) +
    ggbeeswarm::geom_quasirandom(size = 0.2, aes(colour = keep)) +
    ylim(0, 100) +
    theme_cowplot(font_size = 4) +
    theme(axis.text.x = element_text(angle = 60, hjust = 1)),
  ncol = 2,
  align = "v")
```

Some basic summaries of the quality-controlled data are shown in Figure \@ref(fig:qcplot-post-outlier-removal-by-plate-by-mouse).

```{r}
# NOTE: Update the factor columns.
colData(sce) <- DataFrame(
  lapply(colData(sce), function(x) {
    if (is.factor(x)) {
      factor(x)
    } else {
      x
    }
  }),
  row.names = colnames(sce))
```

```{r qcplot-post-outlier-removal-by-plate-by-mouse, fig.cap = "Distributions of various QC metrics for all cells that passed quality control in the data set. This includes the library sizes, number of expressed genes, and proportion of reads mapped to spike-in transcripts or mitochondrial genes.", layout = "l-page", fig.asp = 2 / 3}
plot_grid(
  ggplot(
    data = as.data.frame(colData(sce)),
    aes(
      x = plate_number.mouse,
      y = sum,
      colour = genotype,
      fill = genotype)) +
    geom_violin(scale = "width", width = 0.8, alpha = 0.2) +
    ggbeeswarm::geom_quasirandom(size = 0.1) +
    theme_cowplot(font_size = 4) +
    scale_colour_manual(values = genotype_colours) + 
    scale_fill_manual(values = genotype_colours) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    scale_y_log10(limits = c(1, NA)) +
    annotation_logticks(
      sides = "l",
      short = unit(0.03, "cm"),
      mid = unit(0.06, "cm"),
      long = unit(0.09, "cm")),
  ggplot(
    data = as.data.frame(colData(sce)),
    aes(
      x = plate_number.mouse,
      y = altexps_ERCC_percent,
      colour = genotype,
      fill = genotype)) +
    geom_violin(scale = "width", width = 0.8, alpha = 0.2) +
    ggbeeswarm::geom_quasirandom(size = 0.1) +
    ylim(0, 100) +
    theme_cowplot(font_size = 4) +
    scale_colour_manual(values = genotype_colours) + 
    scale_fill_manual(values = genotype_colours) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)),
  ggplot(
    data = as.data.frame(colData(sce)),
    aes(
      x = plate_number.mouse,
      y = detected,
      colour = genotype,
      fill = genotype)) +
    geom_violin(scale = "width", width = 0.8, alpha = 0.2) +
    ggbeeswarm::geom_quasirandom(size = 0.1) +
    theme_cowplot(font_size = 4) +
    scale_colour_manual(values = genotype_colours) + 
    scale_fill_manual(values = genotype_colours) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    scale_y_log10(limits = c(1, NA)) +
    annotation_logticks(
      sides = "l",
      short = unit(0.03, "cm"),
      mid = unit(0.06, "cm"),
      long = unit(0.09, "cm")),
  ggplot(
    data = as.data.frame(colData(sce)),
    aes(
      x = plate_number.mouse,
      y = subsets_Mt_percent,
      colour = genotype,
      fill = genotype)) +
    geom_violin(scale = "width", width = 0.8, alpha = 0.2) +
    ggbeeswarm::geom_quasirandom(size = 0.1) +
    ylim(0, 100) +
    theme_cowplot(font_size = 4) +
    scale_colour_manual(values = genotype_colours) + 
    scale_fill_manual(values = genotype_colours) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)),
  ncol = 2,
  align = "v")
```

# Examining gene-level metrics

## Inspecting the most highly expressed genes

Figure \@ref(fig:topgenes) shows the most highly expressed genes in the dataset.

```{r topgenes, fig.asp = 1, fig.cap = "Percentage of total counts assigned to the top 50 most highly-abundant features in the data set. For each feature, each bar represents the percentage assigned to that feature for a single cell, while the circle represents the average across all cells. Bars are coloured by the total number of expressed features in each cell, while circles are coloured according to whether the feature is labelled as a control feature."}
plotHighestExprs(sce, n = 50)
```

Figure \@ref(fig:topgenes-filtered) shows the most highly expressed non-mitochdonrial, non-ribosomal protein genes in the dataset.

```{r topgenes-filtered, fig.asp = 1, fig.cap = "Percentage of total counts assigned to the top 50 most highly-abundant features (after excluding mitochondrial and ribosomal protein genes) in the data set. For each feature, each bar represents the percentage assigned to that feature for a single cell, while the circle represents the average across all cells. Bars are coloured by the total number of expressed features in each cell, while circles are coloured according to whether the feature is labelled as a control feature."}
plotHighestExprs(sce[!grepl("^mt|^Rps|^Rpl", rownames(sce)), ], n = 50)
```

## Filtering out low-abundance genes

Low-abundance genes are problematic as zero or near-zero counts do not contain much information for reliable statistical inference [@bourgon2010independent].
These genes typically do not provide enough evidence to reject the null hypothesis during testing, yet they still increase the severity of the multiple testing correction.
In addition, the discreteness of the counts may interfere with statistical procedures, e.g., by compromising the accuracy of continuous approximations.
Thus, low-abundance genes are often removed in many RNA-seq analysis pipelines before the application of downstream methods.

The 'optimal' choice of filtering strategy depends on the downstream application.
A more aggressive filter is usually required to remove discreteness (e.g., for normalization) compared to that required for removing underpowered tests.
For hypothesis testing, the filter statistic should also be independent of the test statistic under the null hypothesis.
Thus, we (or the relevant function) will filter at each step as needed, rather than applying a single filter for the entire analysis.

Several metrics can be used to define low-abundance genes.
The most obvious is the average count for each gene, computed across all cells in the data set.
We typically observe a peak of moderately expressed genes following a plateau of lowly expressed genes (Figure \@ref(fig:abhist)).

```{r abhist, fig.cap = "Histogram of log-average counts for all genes in the combined data set.", results = "hide"}
ave_counts <- calculateAverage(sce)
par(mfrow = c(1, 1))
hist(
  x = log10(ave_counts), 
  breaks = 100, 
  main = "", 
  col = "grey",
  xlab = expression(Log[10] ~ "average count"))
to_keep <- ave_counts > 0
sce <- sce[to_keep, ]
```

We remove `r sum(!to_keep)` genes that are not expressed in any cell.
Such genes provide no information and would be removed by any filtering strategy.
We retain `r sum(to_keep)` for downstream analysis.

# Normalization of cell-specific biases

Read counts are subject to differences in capture efficiency and sequencing depth between cells [@stegle2015computational].
Normalization is required to eliminate these cell-specific biases prior to downstream quantitative analyses.
This is often done by assuming that most genes are not differentially expressed (DE) between cells.
Any systematic difference in count size across the non-DE majority of genes between two cells is assumed to represent bias and is removed by scaling.
More specifically, 'size factors' are calculated that represent the extent to which counts should be scaled in each library.

## Using the deconvolution method to deal with zero counts

Size factors can be computed with several different approaches, e.g., using the `estimateSizeFactorsFromMatrix` function in the `r Biocpkg("DESeq2")` package [@anders2010differential;@love2014moderated], or with the `calcNormFactors` function [@robinson2010scaling] in the `r Biocpkg("edgeR")` package.
However, single-cell data can be problematic for these bulk data-based methods due to the dominance of low and zero counts.
To overcome this, we pool counts from many cells to increase the count size for accurate size factor estimation [@lun2016pooling].
Pool-based size factors are then 'deconvolved' into cell-based factors for cell-specific normalization.
This removes scaling biases associated with cell-specific differences in capture efficiency, sequencing depth and composition biases.

```{r, results = "hide"}
library(scran)
set.seed(5755)
clusters <- quickCluster(sce)
sce <- computeSumFactors(sce, min.mean = 0.1)
summary(sizeFactors(sce))
```

We check that the size factors are roughly aligned with the total library sizes (Figure \@ref(fig:normplot)).
Deviations from the diagonal correspond to composition biases due to differential expression between cell subpopulations.

```{r normplot, fig.cap = "Size factors from deconvolution, plotted against library sizes for all cells in each data set. Axes are shown on a log-scale.", results = "hide", layout = "l-page", fig.asp = 3 / 5}
xlim <- c(1, max(sce$sum) / 1e3)
ylim <- range(sizeFactors(sce))
par(mfrow = c(2, 4))
lapply(levels(sce$plate_number), function(p) {
  sce <- sce[, sce$plate_number == p]
  plot(
    x = sce$sum / 1e3, 
    y = sizeFactors(sce), 
    log = "xy",
    xlab = "Library size (thousands)", 
    ylab = "Size factor",
    main = p,
    xlim = xlim,
    ylim = ylim,
    pch = 16)
})
```

## Applying the size factors to normalize gene expression

The count data are used to compute normalized log-expression values for use in downstream analyses.
Each value is defined as the log~2~-ratio of each count to the size factor for the corresponding cell, after adding a prior count of 1 to avoid undefined values at zero counts.
Division by the size factor ensures that any cell-specific biases are removed.

```{r}
sce <- logNormCounts(sce)
```

## Computing separate size factors for spike-in transcripts

Size factors computed from the counts for endogenous genes are usually not appropriate for normalizing the counts for spike-in transcripts. 
To ensure normalization is performed correctly, we compute a separate set of size factors for the spike-in set.
For each cell, the spike-in-specific size factor is defined as the total count across all transcripts in the spike-in set. 
This assumes that none of the spike-in transcripts are differentially expressed, which is reasonable given that the same amount and composition of spike-in RNA should have been added to each cell [@lun2017assessing]. 

```{r}
sizeFactors(altExp(sce)) <- librarySizeFactors(altExp(sce))
```

# Concluding remarks

```{r}
saveRDS(
  sce,
  here("data", "SCEs", "C075_Grant_Coultas.preprocessed.SCE.rds"),
  compress = "xz")
```

The processed *SingleCellExperiment* object is available (see [`data/SCEs/C075_Grant_Coultas.preprocessed.SCE.rds`](../data/SCEs/C075_Grant_Coultas.preprocessed.SCE.rds)).
This will be used in downstream analyses, e.g. when merging the different samples onto the same coordinate system.

# Additional information {.appendix}

The following are available on request:

- Full CSV tables of any data presented.
- PDF/PNG files of any static plots.

# Session info {.appendix}

The analysis and this document were prepared using the following software:

```{r}
sessioninfo::session_info()
```
