---
title: "Annotating the Grant (C075) retinal epithelial cells data set"
description: |
author:
  - name: Peter Hickey 
    url: https://peterhickey.org
    affiliation: Single Cell Open Research Endeavour (SCORE), WEHI
    affiliation_url: https://www.wehi.edu.au/people/shalin-naik/3310/score
date: "`r Sys.Date()`"
output: distill::distill_article
editor_options: 
  chunk_output_type: console
bibliography: ref.bib
---

```{r setup}
library(SingleCellExperiment)
library(here)
library(scater)
library(scran)
library(ggplot2)
library(cowplot)
library(edgeR)
library(Glimma)
library(BiocParallel)
library(patchwork)
library(pheatmap)

source(here("code", "helper_functions.R"))

# NOTE: Using multiple cores seizes up my laptop. Can use more on unix box.
options("mc.cores" = ifelse(Sys.info()[["nodename"]] == "PC1331", 2L, 8L))
register(MulticoreParam(workers = getOption("mc.cores")))

knitr::opts_chunk$set(fig.path = "C075_Grant_Coultas.annotate_files/")
```

# Preparing the data

We start from the preprocessed *SingleCellExperiment* object created in ['Selection of biologically relevant cells for the Grant (C075) retinal epithelial cells data set'](C075_Grant_Coultas.cell_selection.html).

```{r}
sce <- readRDS(here("data", "SCEs", "C075_Grant_Coultas.cells_selected.SCE.rds"))

# Some useful colours
plate_number_colours <- setNames(
  unique(sce$plate_number_colours),
  levels(sce$plate_number))
sample_type_colours <- setNames(
  unique(sce$sample_type_colours),
  levels(sce$sample_type))
genotype_colours <- setNames(
  unique(sce$genotype_colours),
  levels(sce$genotype))
mouse_colours <- setNames(
  unique(sce$mouse_colours),
  levels(sce$mouse))
sex_colours <- setNames(
  unique(sce$sex_colours),
  levels(sce$sex))
sequencing_run_colours <- setNames(
  unique(sce$sequencing_run_colours),
  levels(sce$sequencing_run))
cluster_colours <- setNames(
  unique(sce$cluster_colours),
  levels(sce$cluster))

# Some useful gene sets
mito_set <- rownames(sce)[any(rowData(sce)$ENSEMBL.SEQNAME == "MT")]

ribo_set <- grep("^Rp(s|l)", rownames(sce), value = TRUE)
# NOTE: A more curated approach for identifying ribosomal protein genes 
#       (https://github.com/Bioconductor/OrchestratingSingleCellAnalysis-base/blob/ae201bf26e3e4fa82d9165d8abf4f4dc4b8e5a68/feature-selection.Rmd#L376-L380)
library(msigdbr)
c2_sets <- msigdbr(species = "Mus musculus", category = "C2")
ribo_set <- union(
  ribo_set,
  c2_sets[c2_sets$gs_name == "KEGG_RIBOSOME", ]$gene_symbol)

sex_set <- rownames(sce)[any(rowData(sce)$ENSEMBL.SEQNAME %in% c("X", "Y"))]

pseudogene_set <- rownames(sce)[
  any(grepl("pseudogene", rowData(sce)$ENSEMBL.GENEBIOTYPE))]
```

# Motivation

The most challenging task in scRNA-seq data analysis is arguably the annotation of cells with meaningful labels.
We might attempt to label cells individually or to label clusters (with cells assigned to those clusters 'inheriting' the cluster-level label).

In ['Selection of biologically relevant cells for the Grant (C075) retinal epithelial cells data set'](C075_Grant_Coultas.cell_selection.html), we obtained one set of labels:

1. 'cluster' labels using clustering. Obtaining clusters of cells is fairly straightforward, but it is more difficult to determine what biological state is represented by each of those clusters.

In this section we use [Pre-defined marker genes] and perform [Cluster marker gene detection] to construct *de novo* marker gene lists that can be used to aid the interpretation of the clustering results, i
The *de novo* marker genes lists use a data driven approach to identify those genes that drive separation between clusters whereas the pre-defined marker genes are a more targeted approach to cluster annotation.
These two approaches complement one another.
We also describe the choice of [Visualization] options for marker gene analyses.

As a reminder, Figure \@ref(fig:mnn-corrected-clusterplot-umap) shows the clustering results overlaid on the UMAP plot and Figure \@ref(fig:mnn-corrected-cluster-barplot) breaks down the clusters by key experimental factors.

```{r mnn-corrected-clusterplot-umap, fig.cap = "UMAP plot, where each point represents a droplet and is coloured according to the legend.", fig.asp = 0.7}
p1 <- ggcells(sce, aes(x = UMAP.1, y = UMAP.2)) +
  geom_point(aes(colour = cluster), size = 0.25) +
  scale_colour_manual(values = cluster_colours) + 
  theme_cowplot(font_size = 8) + 
  xlab("Dimension 1") + 
  ylab("Dimension 2")
p2 <- ggcells(sce, aes(x = UMAP.1, y = UMAP.2)) +
  geom_point(aes(colour = genotype), size = 0.25) +
  scale_colour_manual(values = genotype_colours) + 
  theme_cowplot(font_size = 8) + 
  xlab("Dimension 1") + 
  ylab("Dimension 2")
p3 <- ggcells(sce, aes(x = UMAP.1, y = UMAP.2)) +
  geom_point(aes(colour = sex), size = 0.25) +
  scale_colour_manual(values = sex_colours) + 
  theme_cowplot(font_size = 8) + 
  xlab("Dimension 1") + 
  ylab("Dimension 2")
p4 <- ggcells(sce, aes(x = UMAP.1, y = UMAP.2)) +
  geom_point(aes(colour = plate_number), size = 0.25) +
  scale_colour_manual(values = plate_number_colours) + 
  theme_cowplot(font_size = 8) + 
  xlab("Dimension 1") + 
  ylab("Dimension 2")

(p1 | p2) / (p3 | p4)
```

```{r mnn-corrected-cluster-barplot, fig.asp = 1 / 2, fig.cap = "Breakdown of clusters by experimental factors."}
p1 <- ggcells(sce) + 
  geom_bar(
    aes(x = cluster, fill = genotype),
    position = position_fill(reverse = TRUE)) +
  coord_flip() +
  ylab("Frequency") +
  scale_fill_manual(values = genotype_colours) +
  theme_cowplot(font_size = 8)
p2 <- ggcells(sce) + 
  geom_bar(
    aes(x = cluster, fill = sex),
    position = position_fill(reverse = TRUE)) +
  coord_flip() +
  ylab("Frequency") +
  scale_fill_manual(values = sex_colours) +
  theme_cowplot(font_size = 8)
p3 <- ggcells(sce) + 
  geom_bar(
    aes(x = cluster, fill = plate_number),
    position = position_fill(reverse = TRUE)) +
  coord_flip() +
  ylab("Frequency") +
  scale_fill_manual(values = plate_number_colours) +
  theme_cowplot(font_size = 8)
p4 <- ggplot(as.data.frame(colData(sce)[, "cluster", drop = FALSE])) + 
  geom_bar(aes(x = cluster, fill = cluster)) +
  coord_flip() +
  ylab("Number of droplets") +
  scale_fill_manual(values = cluster_colours) +
  theme_cowplot(font_size = 8) + 
  guides(fill = FALSE)

(p1 | p2) / (p3 | p4)
```

# Pre-defined marker genes

We examine [Zoe's gene list] and a [Cell cycle gene list].

## Zoe's gene list

### Motivation

Zoe sent me a list of marker genes to help characterise the cells^[Email 2020-05-06.].

```{r}
zoes_markers <- readxl::read_excel(
  here(
    "data", 
    "marker_genes",
    "Genes for violin plots Hbo1 retina ECs.xlsx")) %>%
  # NOTE: Zoe forgot to label the cell cycle genes
  dplyr::mutate(
    `Endothelial identity` = ifelse(
      is.na(`Endothelial identity`),
      "Cell cycle",
      `Endothelial identity`),
    Expressed = Gene %in% rownames(sce))
DT::datatable(
  zoes_markers,
  caption = "Zoe's supplied list of marker genes, their 'Endothelial identity', and whether they are expressed in the current dataset.")
```

### Analysis

```{r}
zoes_marker_gene_dir <- here("output", "zoes_marker_genes")
dir.create(zoes_marker_gene_dir, recursive = TRUE)
```

```{r, results = "hide"}
violin_plot_dir <- file.path(zoes_marker_gene_dir, "violin_plots")
dir.create(violin_plot_dir)

pdf(
  file.path(violin_plot_dir, "zoes_markers.violin_plot.logcounts.pdf"),
  width = 5,
  height = 5)
lapply(seq_len(nrow(zoes_markers)), function(i) {
  feature <- zoes_markers$Gene[i]
  plotExpression(
    sce, 
    features = feature,
    x = "cluster",
    exprs_values = "logcounts",
    colour_by = "cluster",
    other_fields = c("sex", "genotype")) + 
    facet_grid(sex ~ genotype) + 
    scale_fill_manual(values = cluster_colours) +
    guides(fill = guide_legend(title = "cluster")) +
    ggtitle(feature)
})
dev.off()

pdf(
  file.path(violin_plot_dir, "zoes_markers.violin_plot.reconstructed.pdf"),
  width = 5,
  height = 5)
lapply(seq_len(nrow(zoes_markers)), function(i) {
  message(i)
  feature <- zoes_markers$Gene[i]
  plotExpression(
    sce, 
    features = feature,
    x = "cluster",
    exprs_values = "reconstructed",
    colour_by = "cluster",
    other_fields = c("sex", "genotype")) + 
    facet_grid(sex ~ genotype) + 
    scale_fill_manual(values = cluster_colours) +
    guides(fill = guide_legend(title = "cluster")) +
    ggtitle(feature)
})
dev.off()
```

Figure \@ref(fig:zoes-markers-heatmap) is a heatmap of Zoe's marker genes.
It is challenging to immediately associate clusters with a cell type on the basis of these marker genes, but some patterns are clear, such as:

- `Artery` marker genes are highly expressed in cluster 7.
- `Artery, tip` marker genes are highly expressed in clusters 5 and 7.
- `Tip` marker genes are highly expressed in cluster 5.
- `Angiogenic` marker genes are highly expressed in clusters 3 and 4. 

<aside>
Violin plots of per-gene expression measurements and heatmaps (`logcounts` and `reconstructed`) can be found in the [`output/zoes_marker_genes/`](../output/zoes_marker_genes/) directory.
</aside>

```{r, results = "hide"}
features <- dplyr::filter(zoes_markers, Expressed) %>% 
  dplyr::pull(Gene)
gene_set <- dplyr::filter(zoes_markers, Expressed) %>% 
  dplyr::pull(`Endothelial identity`)

o <- order(sce$cluster, sce$genotype)

mat <- assay(sce, "logcounts")[features, ]
mat <- mat - rowMeans(mat)
zlim <- c(-max(abs(mat)), max(abs(mat)))
mat[mat < zlim[1]] <- zlim[1]
mat[mat > zlim[2]] <- zlim[2]
p1 <- pheatmap(
  mat = mat[, o],
  cluster_rows = FALSE,
  cluster_cols = FALSE,
  show_colnames = FALSE,
  annotation_row = data.frame(
    gene_set = gene_set,
    row.names = features),
  annotation_col = data.frame(
    cluster = sce$cluster[o],
    genotype = sce$genotype[o],
    row.names = colnames(sce)[o]),
  annotation_colors = list(
    cluster = cluster_colours[levels(sce$cluster)],
    genotype = genotype_colours),
  breaks = seq(zlim[1], zlim[2], length.out = 101),
  silent = TRUE,
  main = "logcounts (row-normalized)",
  fontsize = 6)

mat <- assay(sce, "reconstructed")[features, ]
mat <- mat - rowMeans(mat)
zlim <- c(-max(abs(mat)), max(abs(mat)))
mat[mat < zlim[1]] <- zlim[1]
mat[mat > zlim[2]] <- zlim[2]
p2 <- pheatmap(
  mat = mat[, o],
  cluster_rows = FALSE,
  cluster_cols = FALSE,
  show_colnames = FALSE,
  annotation_row = data.frame(
    gene_set = gene_set,
    row.names = features),
  annotation_col = data.frame(
    cluster = sce$cluster[o],
    genotype = sce$genotype[o],
    row.names = colnames(sce)[o]),
  annotation_colors = list(
    cluster = cluster_colours[levels(sce$cluster)],
    genotype = genotype_colours),
  breaks = seq(zlim[1], zlim[2], length.out = 101),
  silent = TRUE,
  main = "reconstructed (row-normalized)",
  fontsize = 6)
```

```{r zoes-markers-heatmap, fig.wide = TRUE, fig.cap = "Heatmap of row-normalized `logcounts` for Zoe's marker genes. Each column is a sample, each row a gene. Samples are ordered by `cluster` then by `genotype`.", fig.asp = 1.1}
p1
```

```{r}
heatmap_dir <- file.path(zoes_marker_gene_dir, "heatmaps")
dir.create(heatmap_dir)

pdf(
  file.path(heatmap_dir, "zoes_markers.heatmap.logcounts.pdf"),
  width = 5,
  height = 5)
p1
dev.off()

pdf(
  file.path(heatmap_dir, "zoes_markers.heatmap.reconstructed.pdf"),
  width = 5,
  height = 5)
p2
dev.off()
```

## Cell cycle gene list

### Motivation

On occasion, it can be desirable to determine cell cycle activity from scRNA-seq data.
In and of itself, the distribution of cells across phases of the cell cycle is not usually informative, but we can use this to determine if there are differences in cell cycle progression between subpopulations or across treatment conditions.
Many of the key events in the cell cycle (e.g., passage through checkpoints) are post-translational and thus not directly visible in transcriptomic data; nonetheless, there are enough changes in expression that can be exploited to determine cell cycle phase.

### Analysis

#### Using the cyclins

```{r, results = "hide"}
cyclin_genes <- grep("^Ccn[abde][0-9]$", rownames(sce))
cyclin_genes <- rownames(sce)[cyclin_genes]
cyclin_genes
```

The cyclins control progression through the cell cycle and have well-characterized patterns of expression across cell cycle phases.
The cyclins available in this dataset are as follows: `r glue::glue_collapse(cyclin_genes, ", ", last = ", and ")`.

- Cyclin A is expressed across S and G2.
- cyclin B is expressed highest in late G2 and mitosis.
- Cyclin D is expressed throughout but peaks at G1.
- Cyclin E is expressed highest in the G1/S transition.

Inspection of the relative expression of cyclins across the population can often be sufficient to determine the relative cell cycle activity in each cluster.

For example, Figure \@ref(fig:cyclin-heatmap) shows that clusters 1 and 2 have higher expression of cyclins A, B, and E and therefore may be in S,G2 or G2/M phase while the other clusters are scattered across the later phases.

```{r cyclin-heatmap, fig.wide = TRUE, fig.cap = "Heatmap of `logcounts` (left) and row-normalized `logcounts` values (right) for Zoe's marker genes. Each column is a sample, each row a gene. Samples are ordered by `cluster` then by `genotype`. Row (gene) and column (cell) order are preserved across the two heatmaps."}
features <- sort(cyclin_genes)

o <- order(sce$cluster, sce$genotype)

mat <- assay(sce, "logcounts")[features, ]
p1 <- pheatmap(
  mat = mat[, o],
  color = viridisLite::magma(101),
  cluster_rows = FALSE,
  cluster_cols = FALSE,
  show_colnames = FALSE,
  annotation_col = data.frame(
    cluster = sce$cluster[o],
    genotype = sce$genotype[o],
    row.names = colnames(sce)[o]),
  annotation_colors = list(
    cluster = cluster_colours[levels(sce$cluster)],
    genotype = genotype_colours),
  silent = TRUE,
  main = "logcounts",
  fontsize = 6)

mat <- mat - rowMeans(mat)
zlim <- c(-max(abs(mat)), max(abs(mat)))
mat[mat < zlim[1]] <- zlim[1]
mat[mat > zlim[2]] <- zlim[2]
p2 <- pheatmap(
  mat = mat[, o],
  cluster_rows = FALSE,
  cluster_cols = FALSE,
  show_colnames = FALSE,
  annotation_col = data.frame(
    cluster = sce$cluster[o],
    genotype = sce$genotype[o],
    row.names = colnames(sce)[o]),
  annotation_colors = list(
    cluster = cluster_colours[levels(sce$cluster)],
    genotype = genotype_colours),
  breaks = seq(zlim[1], zlim[2], length.out = 101),
  silent = TRUE,
  main = "logcounts (row-normalized)",
  fontsize = 6)

gridExtra::grid.arrange(p1$gtable, p2$gtable, ncol = 2)
```

We can also use standard differential expression methods to look for upregulation of each cyclin, allowing us to determine if there are more cells in the corresponding phase of the cell cycle between subpopulations.

Here we use pairwise Wilcoxon rank sum tests to compute differential expression of cycline genes between each pair of clusters.
The Wilcoxon test estimates effect sizes as overlap proportions (`overlap` in the tables below).
The overlap proportion is defined as the probability that a randomly selected cell in $A$ has a greater expression value of $X$ than a randomly selected cell in $B$.
Overlap proportions near 0 ($A$ is lower than $B$) or 1 ($A$ is higher than $B$) indicate that the expression distributions are well-separated.
The Wilcoxon rank sum test effectively tests for significant deviations from an overlap proportion of 0.5.

```{r}
cyclin_markers <- findMarkers(
  sce, 
  subset.row = sort(cyclin_genes), 
  group = sce$cluster, 
  block = sce$Sample, 
  direction = "up", 
  pval.type = "any",
  test.type = "wilcox")

g2_cluster <- "1"
```

We can infer that cluster `r g2_cluster` likely has more cells in S,G2 or G2/M than the other clusters, based on higher expression of some of the cyclin A, B, and E genes.

```{r}
knitr::kable(
  as.data.frame(cyclin_markers[[g2_cluster]]),
  caption = paste0(
    "Cyclin DE analysis comparing cluster ",
    g2_cluster,
    " to all other clusters."),
  digits = 2)
```

Direct examination of cyclin expression is easily understood, interpreted and validated with other technologies.
However, it is best suited for statements about relative cell cycle activity; for example, we would find it difficult to assign cell cycle phase in Figure \@ref(fig:cyclin-heatmap) without the presence of clusters spanning all phases to provide benchmarks for "high" and "low" expression of each cyclin.
We also assume that cyclin expression is not affected by biological processes other than the cell cycle, which may be a strong assumption in some cases, e.g., malignant cells.

## Summary

We can infer that cluster `r g2_cluster` likely contains cells in S,G2 or G2/M phase (based on higher expression of some of the cyclin A, B, and E genes) and that the remaining clusters are likely in G1 (based on fairly ubiquitous expression of cyclin D genes and no strong upregulation of the other cyclins).

For some time, it was popular to regress out the cell cycle phase prior to downstream analyses.
The aim was to remove uninteresting variation due to cell cycle, thus improving resolution of other biological processes of interest.
However, we do not consider adjusting for cell cycle to be a necessary step in routine scRNA-seq analyses.

Any attempt at removal would need to assume that the cell cycle effect is orthogonal to other biological processes.
If this was violated (i.e. the cell cycle effect was associated with other biological processes), then the regression would potentially remove interesting signal if cell cycle activity varied across clusters or conditions.

# Cluster marker gene detection

## Motivation

To interpret our clustering results, we identify the genes that drive separation between clusters.
These marker genes allow us to assign biological meaning to each cluster based on their functional annotation.
In the most obvious case, the marker genes for each cluster are *a priori* associated with particular cell types, allowing us to treat the clustering as a proxy for cell type identity.
The same principle can be applied to more subtle differences in activation status or differentiation state.

Identification of marker genes is usually based around the retrospective detection of differential expression between clusters^[Differential expression analyses is performed on the original log-expression values.].
Genes that are more strongly DE are more likely to have driven cluster separation in the first place.
The top DE genes are likely to be good candidate markers as they can effectively distinguish between cells in different clusters.

## Statistical methodology and considerations

It is important to have some understanding of the statistical methodology used for marker gene detection.
This section gives an overview.

### Gene lists

For each cluster, the DE results of the relevant comparisons are consolidated into a single output table.
This allows a set of marker genes to be easily defined by taking the top DE genes from each pairwise comparison between clusters.
Other statistics are also reported for each gene, including the adjusted p-values^[It must be stressed that the (adjusted) p-values computed here cannot be properly interpreted as measures of significance because the clusters have been empirically identified from the data. Nonetheless, they can still be used as way to rank 'interesting' genes.] and the log-fold changes relative to every other cluster.

### Use of pairwise comparisons

We intentionally use pairwise comparisons between clusters rather than comparing each cluster to the average of all other cells.
The latter approach is sensitive to the population composition, potentially resulting in wildly different sets of markers when cell type abundances change in different contexts.
In the worst case, the presence of a single dominant subpopulation will drive the selection of top markers for every other cluster, pushing out useful genes that can resolve the various minor subpopulations.
Moreover, pairwise comparisons naturally provide more information to interpret of the utility of a marker, e.g., by providing log-fold changes to indicate which clusters are distinguished by this gene.

### Blocking

We perform intra-plate comparisons by blocking on the `plate_number` to avoid confounding effects from differential expression between plates^[Intra-plate comparisons are robust to differences between libraries but assume that each pair of clusters is present in at least one library. When this is not the case, we cannot commute a logFC for that pair of clusters.].

```{r}
sce$block <- sce$plate_number
```

### Choice of test statistic

The Welch $t$-test is an obvious choice of statistical method to test for differences in expression between clusters.
It is quickly computed and has good statistical properties for large numbers of cells [@soneson2018bias].

Alternatively, we could consider the Wilcoxon rank sum test (also known as the Wilcoxon-Mann-Whitney test, or WMW test).
Its strength lies in the fact that it directly assesses separation between the expression distributions of different clusters.
The WMW test statistic is proportional to the area-under-the-curve (AUC), i.e., the concordance probability, which is the probability of a random cell from one cluster having higher expression than a random cell from another cluster.
In a pairwise comparison, AUCs of 1 or 0 indicate that the two clusters have perfectly separated expression distributions. 
Thus, the WMW test directly addresses the most desirable property of a candidate marker gene, while the $t$-test only does so indirectly via the difference in the means and the intra-group variance.

Another alternative, the binomial test, identifies genes that differ in the proportion of expressing cells between clusters^[For the purposes of this test, a cell is considered to express a gene simply if it has one or more counts for that gene.].
This represents a much more stringent definition of marker genes compared to the other methods, as differences in expression between clusters are effectively ignored if both distributions of expression values are not near zero.
The premise is that genes are more likely to contribute to important biological decisions if they were active in one cluster and silent in another, compared to more subtle 'tuning' effects from changing the expression of an active gene.
From a practical perspective, a binary measure of presence/absence is easier to validate.

The Welch $t$-test is our default method for identifying marker genes.

### Direction and magnitude of the log-fold change

There are 3 ways of specifying the direction of the log-fold change used in the statistical test when comparing cluster $X$ to cluster $Y$:

1. `direction = "any"`: Identify genes that are upregulated or downregulated in $X$ compared to $Y$.
2. `direction = "up"`: Identify genes that are upregulated in $X$ compared to $Y$.
3. `direction = "down"`: Identify genes that are downregulated in  $X$ compared to $Y$.

Generally speaking, downregulated genes are less appealing as markers as it is more difficult to interpret and experimentally validate an absence of expression.
We therefore mostly focus on identifying genes that are upregulated (i.e. `direction = "up"`) in the chosen cluster relative to any/some/all other clusters .
Of course, this increased stringency is not without cost.
If only upregulated genes are requested then any cluster defined by downregulation of a marker gene will not contain that gene among the top set of features in its gene list.
This is occasionally relevant for subtypes or other states that are distinguished by high versus low expression of particular genes.

### Choice of combining pairwise DE results into a marker list

There are 3 ways of combining the pairwise DE results to obtain the per-cluster marker gene lists:

1. [`pval.type = "any"`: Consolidating with DE against *any* other cluster]
2. [`pval.type = "all"`: Consolidating with DE against *all* other clusters]
3. [`pval.type = "some"`: Consolidating with DE against *some* other clusters]

It is important to understand the differences between these strategies, which are described below in some detail.

#### `pval.type = "any"`: Consolidating with DE against *any* other cluster

If `pval.type = "any"`, the null hypothesis is that the gene is not DE in *any* pairwise comparison.
The genes in each cluster's gene list are sorted by the minimum rank (by significance) across all pairwise comparisons (called the `Top` value).
Taking all rows with `Top` values less than or equal to $T$ yields a marker set containing the top $T$ genes from each pairwise comparison.

This strategy guarantees the inclusion of genes that can distinguish between any two clusters.

To demonstrate, let us define a marker set with a $T$ of 1 for a given cluster. 
The set of genes with `Top`$\leq1$ will contain the top gene from each pairwise comparison to every other cluster.
If $T$ is instead, say, $5$, the set will consist of the union of the top 5 genes from each pairwise comparison.
Obviously, multiple genes can have the same `Top` as different genes may have the same rank across different pairwise comparisons.
Conversely, the marker set may be smaller than the product of `Top` and the number of other clusters, as the same gene may be shared across different comparisons.

This approach does not explicitly favour genes that are uniquely expressed in a cluster.
Rather, it focuses on combinations of genes that - together - drive separation of a cluster from the others.
This is more general and robust but tends to yield a less focused marker set compared to the other `pval.type` settings.

For each gene and cluster, the summary effect size is defined as the effect size from the pairwise comparison with the lowest p-value.
The combined p-value is computed by applying Simes' method to all p-values. 
Neither of these values are directly used for ranking and are only reported for the sake of the user.

#### `pval.type = "all"`: Consolidating with DE against *all* other clusters

If `pval.type = "all"`, the null hypothesis is that the gene is not DE in *all* pairwise comparisons.
A combined p-value for each gene is computed using Berger's intersection union test (IUT).
Ranking based on the IUT p-value will focus on genes that are DE in that cluster compared to all other clusters.

This strategy is particularly effective when dealing with distinct clusters that have a unique expression profile.
In such cases, it yields a highly focused marker set that concisely captures the differences between clusters.

However, it can be too stringent if the cluster's separation is driven by combinations of gene expression. For example, consider a situation involving four clusters expressing each combination of two marker genes A and B.
With `pval.type = "all"`, neither A nor B would be detected as markers as it is not uniquely defined in any one cluster.
This is especially detrimental with overclustering where an otherwise acceptable marker is discarded if it is not DE between two adjacent clusters.

For each gene and cluster, the summary effect size is defined as the effect size from the pairwise comparison with the largest p-value.
This reflects the fact that, with this approach, a gene is only as significant as its weakest DE.
Again, this value is not directly used for ranking and are only reported for the sake of the user.

#### `pval.type = "some"`: Consolidating with DE against *some* other clusters

If `pval.type = "some"`, the null hypothesis is that the gene is not DE in *some* of the pairwise comparisons.
Thus, `pval.type = "some"` serves as a compromise between the `pval.type = "all"` and `pval.type = "any"` strategies.
The definition of 'some' is formalized by the minimum proportion (`min.prop`) of significant comparisons per gene and can be tuned to the specifics of the dataset.

For example, suppose we require that the gene is significant in at least `min.prop = 0.5` (i.e. 50%) of comparisons.
A combined p-value is calculated by taking the middlemost value of the Holm-corrected p-values for each gene.
Here, the null hypothesis is that the gene is not DE in at least half of the contrasts.

Genes are then ranked by the combined p-value.
The aim is to provide a more focused marker set without being overly stringent,
However, a downside is that it loses the theoretical guarantees of the `pval.type = "all"` and `pval.type = "any"` strategies.
For example, there is no guarantee that the top set contains genes that can distinguish a cluster from any other cluster, which would have been possible with `pval.type = "any"`.

For each gene and cluster, the summary effect size is defined as the effect size from the pairwise comparison with the `min.prop`-smallest p-value.
This mirrors the p-value calculation but, again, is reported only for the benefit of the user.

## Analysis

CSV files of the cluster marker gene lists and PDFs files of heatmaps for *selected* genes from these cluster marker gene lists can be found in the [`output/cluster_marker_genes/`](../output/cluster_marker_genes/) directory.

<aside>
See [Visualization] for further details of these heatmaps.
</aside>

```{r}
cluster_marker_gene_dir <- here("output", "cluster_marker_genes")
dir.create(cluster_marker_gene_dir, recursive = TRUE)
```

These files are organised as follows:

| prefix      | `test.type` | `direction` | `pval.type` |
|-------------|-------------|-------------|-------------|
| `t_up_all`  | t           | up          | all         |
| `t_up_some` | t           | up          | some        |
| `t_any_any` | t           | any         | any         |


### `t_up_all`

```{r}
test.type <- "t"
direction <- "up"
pval.type <- "all"
min.prop <- NULL

markers <- findMarkers(
  sce,
  groups = sce$cluster,
  test = test.type,
  direction = direction,
  block = sce$block,
  pval.type = pval.type,
  min.prop = min.prop,
  row.data = rowData(sce))
t_up_all_markers <- markers
```

The following table gives the number of marker genes for each cluster by this approach.

<aside>
For spreadsheets and heatmaps of these gene lists see [`output/cluster_marker_genes/t_up_all/`](../output/cluster_marker_genes/t_up_all/).
</aside>

```{r}
n <- sapply(markers, function(x) sum(x$FDR < 0.05))
knitr::kable(
  data.frame(
    cluster = names(markers),
    n = sapply(markers, function(x) sum(x$FDR < 0.05))),
  caption = "Number of marker genes for each cluster (FDR < 0.05).")
```

```{r, message = FALSE}
# Create outputs
prefix <- paste(test.type, direction, pval.type, sep = "_")
marker_dir <- file.path(cluster_marker_gene_dir, prefix)
dir.create(marker_dir)
createClusterMarkerOutputs(
  prefix = prefix, 
  outdir = marker_dir, 
  exprs_values = c("logcounts", "reconstructed"), 
  k = 100,
  width = 6,
  height = 7.5)
```

### `t_up_some`

```{r}
# Sanity check
stopifnot(nlevels(sce$cluster) == 7)
```

We set `min.prop` = $\frac{2}{n - 1}$ where $n$ is the number of clusters (i.e. `min.prop` = $\frac{2}{7 - 1} = \frac{1}{3}$) so that 'some' means 'two or more pairwise comparisons'. 

```{r}
test.type <- "t"
direction <- "up"
pval.type <- "some"
min.prop <- 2 / (nlevels(sce$cluster) - 1)

markers <- findMarkers(
  sce,
  groups = sce$cluster,
  test = test.type,
  direction = direction,
  block = sce$block,
  pval.type = pval.type,
  min.prop = min.prop,
  row.data = rowData(sce))
t_up_some_markers <- markers
```

The following table gives the number of marker genes for each cluster by this approach.

<aside>
For spreadsheets and heatmaps of these gene lists see [`output/cluster_marker_genes/t_up_some/`](../output/cluster_marker_genes/t_up_some/).
</aside>

```{r}
n <- sapply(markers, function(x) sum(x$FDR < 0.05))
knitr::kable(
  data.frame(
    cluster = names(markers),
    n = sapply(markers, function(x) sum(x$FDR < 0.05))),
  caption = "Number of marker genes for each cluster (FDR < 0.05).")
```

```{r, message = FALSE}
# Create outputs
prefix <- paste(test.type, direction, pval.type, sep = "_")
marker_dir <- file.path(cluster_marker_gene_dir, prefix)
dir.create(marker_dir)
createClusterMarkerOutputs(
  prefix = prefix, 
  outdir = marker_dir, 
  exprs_values = c("logcounts", "reconstructed"), 
  k = 100,
  width = 6,
  height = 7.5)
```

### `t_any_any`

```{r}
test.type <- "t"
direction <- "any"
pval.type <- "any"
min.prop <- NULL

markers <- findMarkers(
  sce,
  groups = sce$cluster,
  test = test.type,
  direction = direction,
  block = sce$block,
  pval.type = pval.type,
  min.prop = min.prop,
  row.data = rowData(sce))
t_any_any_markers <- markers
```

The following table gives the number of marker genes for each cluster by this approach.

<aside>
For spreadsheets and heatmaps of these gene lists see [`output/cluster_marker_genes/t_up_any/`](../output/cluster_marker_genes/t_up_any/).
</aside>

```{r}
n <- sapply(markers, function(x) sum(x$FDR < 0.05))
knitr::kable(
  data.frame(
    cluster = names(markers),
    n = sapply(markers, function(x) sum(x$FDR < 0.05))),
  caption = "Number of marker genes for each cluster (FDR < 0.05).")
```

```{r, message = FALSE}
# Create outputs
prefix <- paste(test.type, direction, pval.type, sep = "_")
marker_dir <- file.path(cluster_marker_gene_dir, prefix)
dir.create(marker_dir)
createClusterMarkerOutputs(
  prefix = prefix, 
  outdir = marker_dir, 
  exprs_values = c("logcounts", "reconstructed"), 
  k = 100,
  width = 6,
  height = 7.5)
```

# Visualization

For each marker gene strategy (e.g. `t_up_all`) we provide PDF heatmaps of *selected* marker genes for each cluster in [`output/cluster_marker_genes/`](../output/cluster_marker_genes/).

<aside>
The supplied heatmaps are limited to showing a maximum of 100 genes (any more and they fast become illegible without considerable manual tweaking).
We can assist with customised figures for publication.
</aside>

In this section we describe the rationale behind choices made in creating these heatmaps, namely:

- The considerations behind the [Choice of expression values: `logcounts` vs. `corrected`] used for visualization.
- The [Exclusion of certain types of genes] from the provided heatmaps.

We also use the heatmaps to illustrate the [Limitations of the `t_up_all` strategy] to further motivate the need for the other marker gene lists.

## Choice of expression values: `logcounts` vs. `corrected`  

A reminder that the `logcounts` (log-transformed normalized expression values) are the basis for any and all gene-based analyses, like DE-based marker gene detection.
However, we can visualize the results of such an analysis using either the `logcounts` or the `reconstructed` values (batch-corrected `logcounts`).
The advantage of using the `reconstructed` values for visualization is that these will generally eliminate some of the visual differences between the batches (in this case, between the plates), which can result in 'cleaner' figures.
As always, however, it is essential to also examine the 'raw data' (in this case the `logcounts`) to ensure that the 'cleaner' figures do not belie the truth. 
If you opt to use the `reconstructed` data for a figure it is vital that you make note of this (e.g., in the figure caption).

<aside>
See the 'Data integration' section of [`docs/C075_Grant_Coultas.cell_selection.html`](../docs/C075_Grant_Coultas.cell_selection.html) for details of the `reconstructed` data.
</aside>

To give some examples of the difference between visualizing `logcounts` and `reconstructed` values, Figure \@ref(fig:visualization-violin) illustrates this with a violin plot of *Sox17* expression while Figure \@ref(fig:visualization-heatmap) illustrates this with a heatmap of ribosomal protein gene expression.
Together these figures demonstrate that:

- An arbitrary correction algorithm, such as MNN, is not obliged to preserve the magnitude (or even direction) of differences in per-gene expression when attempting to align multiple batches. This can lead to 'exaggerated' differences (Figure \@ref(fig:visualization-violin)) or, conversely, artificial agreement across batches (Figure \@ref(fig:visualization-heatmap)).
- This means that absolute values (like zero) lose their meaning, i.e. `reconstructed` = 0 does not mean anything special. In contrast, `logcounts` = 0 means that there were zero `counts`, i.e. the gene was not detected in that sample.

```{r visualization-violin, fig.cap = "Violin plot of *Sox17* gene expression using the `logcounts` (left) and the `reconstructed` values (right) for cells in each cluster."}
features <- "Sox17"

p1 <- plotExpression(
  sce, 
  features = features,
  x = "cluster",
  exprs_values = "logcounts",
  colour_by = "cluster",
  other_fields = c("sex", "genotype")) + 
  scale_fill_manual(values = cluster_colours) +
  guides(fill = FALSE) +
  ggtitle(features)

p2 <- plotExpression(
  sce, 
  features = features,
  x = "cluster",
  exprs_values = "reconstructed",
  colour_by = "cluster",
  other_fields = c("sex", "genotype")) + 
  scale_fill_manual(values = cluster_colours) +
  guides(fill = FALSE) +
  ggtitle(features)

p1 | p2
```

```{r visualization-heatmap, fig.cap = "Heatmap of some ribosomoal protein gene expression using the `logcounts` (left) and the `reconstructed` values (right) for cells in each cluster. Row (gene) and column (cell) order are preserved across the two heatmaps.", fig.asp = 1.1}
features <- intersect(rownames(sce), ribo_set)[1:50]
o <- order(sce$cluster)

mat <- assay(sce, "logcounts")[features, ]
mat <- mat - rowMeans(mat)
zlim <- c(-max(abs(mat)), max(abs(mat)))
p1 <- pheatmap(
  mat = mat[, o],
  cluster_rows = FALSE,
  cluster_cols = FALSE,
  show_colnames = FALSE,
  annotation_col = data.frame(
    cluster = sce$cluster[o],
    row.names = colnames(sce)[o]),
  annotation_colors = list(
    cluster = cluster_colours[levels(sce$cluster)]),
  breaks = seq(zlim[1], zlim[2], length.out = 101),
  silent = TRUE,
  fontsize = 6,
  main = "logcounts (row-normalized)")

mat <- assay(sce, "reconstructed")[features, ]
mat <- mat - rowMeans(mat)
zlim <- c(-max(abs(mat)), max(abs(mat)))
p2 <- pheatmap(
  mat = mat[, o],
  cluster_rows = FALSE,
  cluster_cols = FALSE,
  show_colnames = FALSE,
  annotation_col = data.frame(
    cluster = sce$cluster[o],
    row.names = colnames(sce)[o]),
  annotation_colors = list(
    cluster = cluster_colours[levels(sce$cluster)]),
  breaks = seq(zlim[1], zlim[2], length.out = 101),
  silent = TRUE,
  fontsize = 6,
  main = "reconstructed (row-normalized)")

gridExtra::grid.arrange(p1$gtable, p2$gtable, ncol = 2)
```

## Limitations of the `t_up_all` strategy

Figure \@ref(fig:t-up-all-heatmap) is a heatmap showing the expression of the top-10 marker genes ($FDR < 0.05$) for each cluster from the [`t_up_all`] analysis. 
From this figure we can observe that some clusters do not have any marker genes, and some other clusters only have a small number of marker genes, using the `t_up_all` strategy.
The lack of marker genes for some clusters under the [`t_up_all`] strategy necessitates the other strategies ([`t_up_some`] and [`t_any_any`]).

```{r t-up-all-heatmap, fig.wide = TRUE, fig.cap = "Heatmap of top-10 `t_up_all` marker genes (FDR < 0.05) using the row-normalized `logcounts` for cells in each cluster. Each column is a sample, each row a gene. Note that some clusters have as few as zero upregulated cluster-specific marker genes.", fig.asp = 1.1}
markers <- t_up_all_markers

k <- 10
marker_names <- lapply(markers, function(x) {
  xx <- x[x$FDR < 0.05, ]
  rownames(xx[order(xx$summary.logFC, decreasing = TRUE), ])
})
features <- unlist(lapply(marker_names, head, n = k))
features <- unique(features)

o <- order(sce$cluster, sce$genotype)

mat <- assay(sce, "logcounts")[features, ]
mat <- mat - rowMeans(mat)
zlim <- c(-max(abs(mat)), max(abs(mat)))
mat[mat < zlim[1]] <- zlim[1]
mat[mat > zlim[2]] <- zlim[2]
pheatmap(
  mat = mat[, o],
  cluster_rows = FALSE,
  cluster_cols = FALSE,
  show_colnames = FALSE,
  annotation_row = data.frame(
    cluster = rep(levels(sce$cluster), times = pmin(lengths(marker_names), k)),
    row.names = features),
  annotation_col = data.frame(
    cluster = sce$cluster[o],
    genotype = sce$genotype[o],
    row.names = colnames(sce)[o]),
  annotation_colors = list(
    cluster = cluster_colours[levels(sce$cluster)],
    genotype = genotype_colours),
  breaks = seq(zlim[1], zlim[2], length.out = 101),
  main = "logcounts  (row-normalized)",
  fontsize = 6)
```

## Exclusion of certain types of genes

Figure \@ref(fig:t-up-some-cluster-2-heatmap) is a heatmap showing the expression of the top-50 marker genes for cluster 2 from the [`t_up_some`] analysis. 
From this figure we can observe that many of the cluster 2 `t_up_some` marker genes are pseudogenes, while several others are ribosomal protein genes and sex chromosome genes.
This prompted Zoe and Anne to request heatmaps that exclude mitochondrial genes, ribosomal protein genes, sex chromosome genes, and pseudogenes.

```{r t-up-some-cluster-2-heatmap, fig.wide = TRUE, fig.cap = "Heatmap of top-50 `t_up_all` marker genes for cluster 2 using the row-normalized `logcounts` for cells in each cluster. Each column is a sample, each row a gene. Genes are annotated according to `gene_type`.", fig.asp = 1.1}
markers <- t_up_some_markers[[2]]

k <- 50
features <- head(rownames(markers[markers$FDR < 0.05, ]), k)

o <- order(sce$cluster, sce$genotype)

mat <- assay(sce, "logcounts")[features, ]
mat <- mat - rowMeans(mat)
zlim <- c(-max(abs(mat)), max(abs(mat)))
mat[mat < zlim[1]] <- zlim[1]
mat[mat > zlim[2]] <- zlim[2]
pheatmap(
  mat = mat[, o],
  cluster_rows = FALSE,
  cluster_cols = FALSE,
  show_colnames = FALSE,
  annotation_col = data.frame(
    cluster = sce$cluster[o],
    genotype = sce$genotype[o],
    row.names = colnames(sce)[o]),
  annotation_row = data.frame(
    gene_type = dplyr::case_when(
      features %in% mito_set ~ "mito",
      features %in% ribo_set ~ "ribo",
      features %in% sex_set ~ "sex",
      features %in% pseudogene_set ~ "pseudo",
      TRUE ~ "other"),
    row.names = features),
  annotation_colors = list(
    cluster = cluster_colours[levels(sce$cluster)],
    genotype = genotype_colours,
    gene_type = c(
      "pseudo" = "#2297E6",
      "ribo" = "#61D04F",
      "sex" = "#28E2E5",
      "mito" = "#DF536B", 
      "other" = "white")),
  breaks = seq(zlim[1], zlim[2], length.out = 101),
  main = "logcounts  (row-normalized)",
  fontsize = 6)
```

# Summary

We have performed a focused analysis using Zoe's marker genes and the cyclin genes, and identified cluster marker genes for each cluster using several strategies.
Some preliminary high-level summaries of the clusters are as follows:

- Clusters 1, 5, and 7 can be readily distinguished from the other clusters (`t_up_all` analysis).
    - Cluster 1 has very high and distinct expression of many genes, most obviously including *Hist1h2* genes.
    - Cluster 5 has high and fairly distinct expression of Zoe's `Artery, Tip` and `Tip` marker genes.
    - Cluster 7 has very high and distinct expression of many genes, including Zoe's `Artery` marker genes.
- Clusters 2 and 6 share some marker genes with each other but also with other clusters (`t_up_some` analysis).
    - Cluster 2 shares many marker genes with cluster 1.
    - Cluster 6 shares some markers with cluster 1 and some with clusters 3 or 4.
- Clusters 3 and 4 are perhaps less distinct than the other clusters and share some marker genes with each other but  (`t_up_all`, `t_up_some`, and `t_any_any` analyses).
    - Cluster 3 shares some markers with clusters $4 - 7$.
    - Cluster 4 is perhaps the least distinct cluster in terms of marker genes.

This preliminary summary is just that, preliminary.
The provided cluster marker gene lists should be used to develop biologically relevant, meaningful, and useful labels for cells/clusters in this dataset.
The cluster marker gene lists can be analysed like any other gene list, such as by using gene set enrichment analysis against the Gene Ontology (GO) or Kyoto Encyclopedia of Genes and Genomes (KEGG) databases.

<aside>
We strongly recommend that you visualise the expression patterns of any genes of interest to better understand what is driving their inclusion in the marker gene lists.
</aside>

<!-- # Concluding remarks -->

<!-- TODO: If Zoe provides cell or cluster-level annotation, I'll add them to the bottom of this report and add to the SCE. -->

<!-- ```{r} -->
<!-- saveRDS( -->
<!--   sce, -->
<!--   here("data", "SCEs", "C075_Grant_Coultas.annotated.SCE.rds"), -->
<!--   compress = "xz") -->
<!-- ``` -->

<!-- The processed *SingleCellExperiment* object is available (see [`data/SCEs/C075_Grant_Coultas.annotated.SCE.rds`](../data/SCEs/C075_Grant_Coultas.annotated.SCE.rds)). -->
<!-- This will be used in downstream analyses, e.g., differential expression analysis between conditions within each cluster and differential abundance analyses between conditions for each cluster. -->

# Additional information {.appendix}

The following are available on request:

- Full CSV tables of any data presented.
- PDF/PNG files of any static plots.

# Session info {.appendix}

<summary>The analysis and this document were prepared using the following software (click triangle to expand)</summary>
<details>

```{r}
sessioninfo::session_info()
```
